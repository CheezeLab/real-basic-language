// 함수 선언문 vs 함수 표현식

// 함수 선언문
function sayHello1() {
  console.log("Hello");
}

sayHello1();

// 함수 표현식(이름이 없는 함수를 만들고 변수를 선언해서 함수 할당)
// 사용방식, 실행방식, 동작방식 동일
let sayHello2 = function () {
  console.log("Hello");
};

sayHello2();

// 작성 문법외에 차이점?
// 해답: 호출할 수 있는 타이밍

// 함수 선언문: 어디서든 호출 가능
sayHello3();
// 동작가능(자바스크립트의 내부 알고리즘 때문)
// 실행 전, 초기화 단계에서 코드의 모든 함수 선언문을 찾아 생성해 둠
// 눈으로 보이는 범위보다 사용가능 범위가 코드위치 보다 올라감 => 호이스팅 (실제 코드 위치가 올라가는 걸 의미하지 않음)

function sayHello3() {
  console.log("Hello");
}

// 함수 표현식: 코드에 도달하면 생성
// 자바스크립트가 한줄씩 읽으면서 실행하고, 해당 코드에 도달했을 때 비로소 생성
// 그렇기 때문에 그 이후에만 사용가능

// 뭐가 더 좋음?
// 대부분의 상황에선 크게 상관없음(에러가 생기면 위로 올리면 그만)
// 하지만 신경쓰기 싫다 => 함수 선언문(더 자유롭고 편하게 코딩)

// 화살표 함수(지금까지 배운 함수를 보다 간결하게 작성가능)
let add1 = function (num1, num2) {
  return num1 + num2;
};

// function 단어가 없어지고 괄호 뒤쪽 화살표 삽입
let add2 = (num1, num2) => {
  return num1 + num2;
};
// 코드 구문이 한줄이고 리턴문이 있기 때문에 이렇게도 가능(리턴문이 한줄이라면 괄호도 생략가능)
let add3 = (num1, num2) => num1 + num2;
// 인자 값이 하나라면 괄호 생략 가능
let satHello4 = (name) => `Hello, ${name}`;
// 인수가 없는 경우 괄호 필수
let showError = () => {
  console.log("error");
};
// 리턴문이 있다고 해도 리턴문 전 여러줄의 코드가 있으면 일반(소)괄호 말고 중괄호 사용
let add4 = (num1, num2) => {
  const result = num1 + num2;
  return result;
};

// 참고, 함수 표현식 보단 선언문이 자유롭긴 함
// 화살표 함수는 ES6 이후 굉장히 활발히 사용되고 있으므로 필수적으로 알아둘 것
